package org.eqasim.core.analysis.pt;

import org.eqasim.core.components.transit.events.PublicTransitEvent;
import org.eqasim.core.components.transit.events.PublicTransitEventMapper;
import org.matsim.api.core.v01.Id;
import org.matsim.api.core.v01.Scenario;
import org.matsim.core.api.experimental.events.EventsManager;
import org.matsim.core.config.CommandLine;
import org.matsim.core.config.CommandLine.ConfigurationException;
import org.matsim.core.config.Config;
import org.matsim.core.config.ConfigUtils;
import org.matsim.core.events.EventsUtils;
import org.matsim.core.events.MatsimEventsReader;
import org.matsim.core.scenario.ScenarioUtils;
import org.matsim.core.utils.geometry.CoordUtils;
import org.matsim.pt.transitSchedule.api.TransitSchedule;
import org.matsim.pt.transitSchedule.api.TransitScheduleReader;
import org.matsim.pt.transitSchedule.api.TransitStopFacility;

import java.io.*;
import java.util.*;

/**
 * This class allows to aggregate MATSim simulations outputs into statistics regarding traveler traffic in PT stations
 * This script is meant to be called through the command line with these arguments:
 * --events-path=eventsPath --schedule-path=schedulePath --outputPath=outputPath [--max-clustering-distance=300] [--modes=mode1,mode2,...,mode3] [--baseline-path=baselinePath]
 * The events-path argument should point to a MATSim output events file generated by a simulation (usually named output_events.xml.gz)
 * The schedule-path argument should point to a MATSim transit schedule file (typically the output_transitSchedule.xml.gz generated by the same simulation as the events file)
 * The output-path argument should be a CSV file. This script will write a file with the header stop_id;stop_name;x;y;nb_accesses;nb_egresses
 * For each station indicated within the CSV, the nb_accesses and nb_egresses fields represent the number of travelers that took started or ended a PT trip from or at that station respectively
 * The PT stations are clustered, meaning that stations that are close enough to each other are considered as one (a so have one line in the generated CSV)
 * The clustering is sequential as the events are processed. Meaning that the stop_id and stop_name in the CSV will be the one of the first encountered station of the cluster in the events
 * The max-clustering-distance argument indicates the range distance within which stops should be considered the same. By default, this argument is set to 300 meters
 * Example: Stations A, B, C with distances AB=200, AC=500, BC=300. With maxClusteringDistance=350.
 * If stations are encountered in the order A->B->C, the CSV will have a line for A aggregating statistics for A & B and a line for C
 * If stations are encountered in the order C->B->A, the CSV will have a line for A and a line for C aggregating statistics for B & C
 * The modes argument should be comma separated of pt modes allows to filter and take accounts only trips with one of the specified modes. e.g:--modes=bus,rail0
 * The --baseline-path should point to a CSV file generated by this program. It allows to gather statistics in comparison to another file.
 * For each considered stop, the nb_accesses and nb_egresses fields represent the difference with regard to the baseline. Written = current - baseline
 * In this case, The clustering process starts with singular clusters of the stations already written in the baseline-file.
 * If one of the stations IDs present in the baseline file can't be found in the schedule file, it is simply ignored
 * This class can be used directly as a main class as it can be used as a library.
 * Basically, the second case would be when you want to read the events file only once and performed multiple analyses
 * In order to do that, call the prepare method before reading the file and the writeAnalysis afterwards.
 */
public class RunPublicTransportStopsUsageAnalysis {

    public static final String STOPS_USAGES_STOP_ID_COLUMN = "stop_id";
    public static final String STOPS_USAGES_NB_ACCESSES_COLUMN = "nb_accesses";
    public static final String STOPS_USAGES_NB_EGRESSES_COLUMN = "nb_egresses";
    public static final int DEFAULT_CLUSTERING_DISTANCE = 300;

    private final String baselinePath;
    private final String modes;
    private final PublicTransportTripListener tripListener;
    private final String outputPath;
    private final TransitSchedule schedule;
    private final int maxClusteringDistance;

    public RunPublicTransportStopsUsageAnalysis(TransitSchedule schedule, String outputPath, Optional<String> modes, Optional<String> baselinePath) {
        this(schedule, DEFAULT_CLUSTERING_DISTANCE, outputPath, modes, baselinePath, new PublicTransportTripListener(schedule));
    }

    public RunPublicTransportStopsUsageAnalysis(TransitSchedule schedule, String outputPath, Optional<String> modes, Optional<String> baselinePath, PublicTransportTripListener tripListener) {
        this(schedule, DEFAULT_CLUSTERING_DISTANCE, outputPath, modes, baselinePath, tripListener);
    }

    /**
     * @param schedule
     * @param maxClusteringDistance
     * @param outputPath
     * @param modes
     * @param baselinePath
     * @param tripListener: If specified, uses the passed PublicTransportTripListener objects to retrieve PT trips instead of creating a dedicated one
     */
    public RunPublicTransportStopsUsageAnalysis(TransitSchedule schedule, int maxClusteringDistance, String outputPath, Optional<String> modes, Optional<String> baselinePath, PublicTransportTripListener tripListener) {
        this.schedule = schedule;
        this.outputPath = outputPath;
        this.modes = modes.orElse(null);
        this.baselinePath = baselinePath.orElse(null);
        this.tripListener = tripListener;
        this.maxClusteringDistance = maxClusteringDistance;
    }

    /**
     * Adds the PublicTransportTripListener of this analysis as a handler to the EventsManager
     * If the PublicTransportTripListener object was passed as an argument to the constructor when initializing the analysis. You might not need to call this method before reading the file if the PublicTransportTripListener is added as a handler somewhere else
     * @param eventsManager: The EventsManager object into which the PublicTransportTripListener will be added as a handler
     */
    public void prepare(EventsManager eventsManager) {
        eventsManager.addHandler(this.tripListener);
    }

    /**
     * Performs tha analysis and writes it in the output file
     */
    public void writeAnalysis() throws IOException {
        Set<String> modes;
        if (this.modes != null) {
            modes = new HashSet<>(List.of(this.modes.split(",")));
        } else {
            modes = new HashSet<>();
        }

        Map<Id<TransitStopFacility>, PublicTransportStationUsageItem> usagesMap;

        if (this.baselinePath != null) {
            usagesMap = readBaselineUsages(baselinePath, schedule);

        } else {
            usagesMap = new HashMap<>();
        }

        Map<Id<TransitStopFacility>, Id<TransitStopFacility>> fallbacksMap = new HashMap<>();
        for(Id<TransitStopFacility> transitStopFacilityId: usagesMap.keySet()){
            fallbacksMap.put(transitStopFacilityId, transitStopFacilityId);
        }

        for (PublicTransportTripItem item : this.tripListener.getTripItems()) {
            if (modes.size() > 0 && !modes.contains(item.routeMode)) {
                continue;
            }

            TransitStopFacility fallbackAccessFacility = schedule.getFacilities().get(getFallback(this.maxClusteringDistance, this.schedule, item.accessStopId, fallbacksMap));
            TransitStopFacility fallbackEgressFacility = schedule.getFacilities().get(getFallback(this.maxClusteringDistance, this.schedule, item.egressStopId, fallbacksMap));
            PublicTransportStationUsageItem.initOrAddAccess(fallbackAccessFacility, usagesMap);
            PublicTransportStationUsageItem.initOrAddEgress(fallbackEgressFacility, usagesMap);
        }

        new PublicTransportStationUsageWriter(usagesMap.values()).write(outputPath);
    }

    /**
     * Allows to run the analysis from the command lines
     * @param args
     * @throws IOException
     * @throws ConfigurationException
     */
    static public void main(String[] args) throws IOException, ConfigurationException {
        CommandLine cmd = new CommandLine.Builder(args) //
                .requireOptions("events-path", "output-path", "schedule-path")
                .allowOptions("modes", "baseline-path")//
                .build();

        String outputPath = cmd.getOptionStrict("output-path");
        String eventsPath = cmd.getOptionStrict("events-path");

        Config config = ConfigUtils.createConfig();
        Scenario scenario = ScenarioUtils.createScenario(config);

        new TransitScheduleReader(scenario).readFile(cmd.getOptionStrict("schedule-path"));
        TransitSchedule schedule = scenario.getTransitSchedule();


        RunPublicTransportStopsUsageAnalysis analysis = new RunPublicTransportStopsUsageAnalysis(schedule, outputPath, cmd.getOption("modes"), cmd.getOption("baseline-path"));
        EventsManager eventsManager = EventsUtils.createEventsManager();
        analysis.prepare(eventsManager);

        MatsimEventsReader reader = new MatsimEventsReader(eventsManager);
        reader.addCustomEventMapper(PublicTransitEvent.TYPE, new PublicTransitEventMapper());
        reader.readFile(eventsPath);

        analysis.writeAnalysis();
    }


    /**
     * Retrieves the fallback station that should used to gather statistics about a given station.
     * @param maxClusteringDistance: The furthest distance between the given stop and the resulting stop it can be clustered with.
     * @param schedule: The transit schedule to use to convert Id<TransitStopFacility> objects to TransitStopFacility ones
     * @param transitStopFacilityId: The ID of the stop that you desire to cluster
     * @param fallbacksMap: The current mapping stop -> cluster center stop. If the map already has a value for the given stop, it's directly returned. Otherwise, this mapping will be updated in the process
     * @return The center station of the cluster that the given station should be aggregated with
     */
    public static Id<TransitStopFacility> getFallback(int maxClusteringDistance, TransitSchedule schedule, Id<TransitStopFacility> transitStopFacilityId, Map<Id<TransitStopFacility>, Id<TransitStopFacility>> fallbacksMap) {
        if(fallbacksMap.containsKey(transitStopFacilityId)) {
            return fallbacksMap.get(transitStopFacilityId);
        }
        TransitStopFacility facility = schedule.getFacilities().get(transitStopFacilityId);
        TransitStopFacility nearestFacility = null;
        double nearestDistance = -1.0;
        for (Id<TransitStopFacility> fallbackFacilityId : fallbacksMap.values()) {
            TransitStopFacility fallbackFacility = schedule.getFacilities().get(fallbackFacilityId);
            double distance = CoordUtils.calcEuclideanDistance(facility.getCoord(), fallbackFacility.getCoord());
            if (nearestFacility == null || nearestDistance > distance) {
                nearestFacility = fallbackFacility;
                nearestDistance = distance;
            }
        }
        if (nearestDistance < 0 || nearestDistance > maxClusteringDistance) {
            nearestFacility = facility;
        }
        fallbacksMap.put(transitStopFacilityId, nearestFacility.getId());
        return nearestFacility.getId();
    }

    /**
     * Loads a CSV file written by this class and parse the stations usages. The CSV file should have the following header: stop_id;stop_name;x;y;nb_accesses;nb_egresses
     * @param usagesPath: The path of the file to load
     * @param schedule: The transit schedule that the stations should belong to. Stations absent from the schedule are ignored
     * @return The usage items of the stations present in the file that are also present in the schedule
     * @throws IOException
     */
    public static Map<Id<TransitStopFacility>, PublicTransportStationUsageItem> readBaselineUsages(String usagesPath, TransitSchedule schedule) throws IOException {
        Map<Id<TransitStopFacility>, PublicTransportStationUsageItem> usagesMap = new HashMap<>();
        String line;
        List<String> header = null;

        BufferedReader reader = new BufferedReader(
                new InputStreamReader(new FileInputStream(usagesPath)));

        while ((line = reader.readLine()) != null) {
            List<String> row = Arrays.asList(line.split(";"));

            if (header == null) {
                header = row;
            } else {
                String stopId = row.get(header.indexOf(STOPS_USAGES_STOP_ID_COLUMN));
                Id<TransitStopFacility> transitStopFacilityId = Id.create(stopId, TransitStopFacility.class);
                TransitStopFacility transitStopFacility = schedule.getFacilities().get(transitStopFacilityId);
                if (transitStopFacility == null) {
                    continue;
                }
                int nbAccesses = -Integer.parseInt(row.get(header.indexOf(STOPS_USAGES_NB_ACCESSES_COLUMN)));
                int nbEgresses = -Integer.parseInt(row.get(header.indexOf(STOPS_USAGES_NB_EGRESSES_COLUMN)));
                usagesMap.put(transitStopFacilityId, new PublicTransportStationUsageItem(transitStopFacility, nbAccesses, nbEgresses));
            }
        }
        return usagesMap;
    }
}
